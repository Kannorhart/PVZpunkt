import matplotlib.pyplot as plt
import numpy as np
import json
import os

# Загрузить данные из файла результатов моделирования
def загрузить_данные_моделирования():
    """Загрузить данные моделирования из файла результатов"""
    if os.path.exists('результаты_моделирования.json'):
        with open('результаты_моделирования.json', 'r', encoding='utf-8') as f:
            return json.load(f)
    else:
        # Если файл не существует, использовать тестовые данные
        print("Файл результатов моделирования не найден. Используются тестовые данные.")
        return {
            'сценарии': ['Базовый', 'С самообслуживанием', 'С пчелиным алгоритмом'],
            'времена_ожидания': [[1, 2, 3], [1, 2, 3, 4], [1, 2]],
            'средние_времена_ожидания': [2.1, 1.3, 1.2],
            'ci_время_ожидания': [0.1, 0.1, 0.1],
            'максимальные_времена_ожидания': [5.2, 3.1, 2.8],
            'ci_макс_время_ожидания': [0.2, 0.2, 0.2],
            'обслуженные_клиенты': [69, 113, 113],
            'ci_обслуженных': [5, 5, 5],
            'клиенты_отказались': [19, 3, 3],
            'ci_отказов': [2, 2, 2],
            'коэффициенты_загрузки': [92, 75, 65],
            'ci_загрузки': [3, 3, 3],
            'улучшения': [0, 38, 43],
            'улучшения_удовлетворенности': [0, 85, 85],
            'события': [
                [[i*1, 'прибыл'] for i in range(88)] + [[i*1.2, 'обслужен'] for i in range(69)] + [[i*1.5, 'отказался'] for i in range(19)],
                [[i*0.5, 'прибыл'] for i in range(116)] + [[i*0.6, 'обслужен'] for i in range(113)] + [[i*2, 'отказался'] for i in range(3)],
                [[i*0.5, 'прибыл'] for i in range(116)] + [[i*0.6, 'обслужен'] for i in range(113)] + [[i*2, 'отказался'] for i in range(3)]
            ]
        }

# Загрузить данные
данные = загрузить_данные_моделирования()
сценарии = данные['сценарии']
времена_ожидания = данные.get('времена_ожидания', [])
средние_времена_ожидания = данные['средние_времена_ожидания']
ci_время_ожидания = данные.get('ci_время_ожидания', [0] * len(сценарии))
максимальные_времена_ожидания = данные['максимальные_времена_ожидания']
ci_макс_время_ожидания = данные.get('ci_макс_время_ожидания', [0] * len(сценарии))
обслуженные_клиенты = данные['обслуженные_клиенты']
ci_обслуженных = данные.get('ci_обслуженных', [0] * len(сценарии))
клиенты_отказались = данные['клиенты_отказались']
ci_отказов = данные.get('ci_отказов', [0] * len(сценарии))
коэффициенты_загрузки = данные['коэффициенты_загрузки']
ci_загрузки = данные.get('ci_загрузки', [0] * len(сценарии))
события = данные.get('события', [])


# Если данные об улучшениях есть в файле, использовать их, иначе рассчитать
if 'улучшения' in данные:
    улучшения = данные['улучшения']
else:
    # Рассчитать улучшения времени ожидания
    базовое_время = средние_времена_ожидания[0]
    if базовое_время > 0:
        улучшения = [0]  # Базовый сценарий
        for i in range(1, len(средние_времена_ожидания)):
            улучшение = ((базовое_время - средние_времена_ожидания[i]) / базовое_время) * 100
            улучшения.append(max(0, улучшение))
    else:
        улучшения = [0] * len(средние_времена_ожидания)

if 'улучшения_удовлетворенности' in данные:
    улучшения_удовлетворенности = данные['улучшения_удовлетворенности']
else:
    # Рассчитать улучшение удовлетворенности клиентов
    базовые_отказы = клиенты_отказались[0]
    if базовые_отказы > 0:
        улучшения_удовлетворенности = [0]  # Базовый сценарий
        for i in range(1, len(клиенты_отказались)):
            улучшение = ((базовые_отказы - клиенты_отказались[i]) / базовые_отказы) * 100
            улучшения_удовлетворенности.append(max(0, улучшение))
    else:
        улучшения_удовлетворенности = [0] * len(клиенты_отказались)

def создать_расширенную_визуализацию():
    """Создать расширенную визуализацию результатов имитации"""

    # Создать фигуру с подграфиками с улучшенным размером и интервалами
    fig, axes = plt.subplots(4, 2, figsize=(18, 24))  # Увеличено количество строк до 4
    fig.suptitle('Оптимизация работы ПВЗ: Результаты имитационного моделирования', fontsize=16)

    # Увеличить расстояние между подграфиками
    plt.subplots_adjust(hspace=0.5, wspace=0.3)

    # 1. Сравнение среднего времени ожидания
    bars1 = axes[0, 0].bar(сценарии, средние_времена_ожидания, yerr=ci_время_ожидания, color=['red', 'orange', 'green'], capsize=5)
    axes[0, 0].set_ylabel('Среднее время ожидания (минуты)')
    axes[0, 0].set_title('Среднее время ожидания по сценариям')
    axes[0, 0].set_ylim(0, max(средние_времена_ожидания) * 1.3)

    # Добавить метки значений на столбцах
    for bar, value in zip(bars1, средние_времена_ожидания):
        axes[0, 0].text(bar.get_x() + bar.get_width()/2, bar.get_height() + max(средние_времена_ожидания) * 0.02,
                       f'{value:.3f}', ha='center', va='bottom', fontsize=10)

    # 2. Сравнение обслуженных клиентов
    bars2 = axes[0, 1].bar(сценарии, обслуженные_клиенты, yerr=ci_обслуженных, color=['red', 'orange', 'green'], capsize=5)
    axes[0, 1].set_ylabel('Обслужено клиентов')
    axes[0, 1].set_title('Клиенты обслужены по сценариям')
    axes[0, 1].set_ylim(0, max(обслуженные_клиенты) * 1.2)

    # Добавить метки значений на столбцах
    for bar, value in zip(bars2, обслуженные_клиенты):
        axes[0, 1].text(bar.get_x() + bar.get_width()/2, bar.get_height() + max(обслуженные_клиенты) * 0.02,
                       f'{value:.0f}', ha='center', va='bottom', fontsize=10)

    # 3. Boxplot времени ожидания
    if времена_ожидания and len(времена_ожидания) == len(сценарии):
        axes[1, 0].boxplot(времена_ожидания, tick_labels=сценарии)
    else:
        axes[1, 0].text(0.5, 0.5, 'Данные о времени ожидания отсутствуют или некорректны', ha='center', va='center')
    axes[1, 0].set_ylabel('Время ожидания (минуты)')
    axes[1, 0].set_title('Boxplot времени ожидания')

    # 4. ECDF времени ожидания
    for i, scenario_waiting_times in enumerate(времена_ожидания):
        if scenario_waiting_times:
            sorted_times = np.sort(scenario_waiting_times)
            yvals = np.arange(len(sorted_times))/float(len(sorted_times)-1) if len(sorted_times) > 1 else np.array([0])
            axes[1, 1].plot(sorted_times, yvals, label=сценарии[i])
    axes[1, 1].set_xlabel('Время ожидания (минуты)')
    axes[1, 1].set_ylabel('ECDF')
    axes[1, 1].set_title('ECDF времени ожидания')
    axes[1, 1].legend()

    # 5. Сравнение клиентов, ушедших из-за очереди
    bars3 = axes[2, 0].bar(сценарии, клиенты_отказались, yerr=ci_отказов, color=['red', 'orange', 'green'], capsize=5)
    axes[2, 0].set_ylabel('Клиенты, ушедшие из-за очереди')
    axes[2, 0].set_title('Отток клиентов по сценариям')
    axes[2, 0].set_ylim(0, max(клиенты_отказались) * 1.2)

    # Добавить метки значений на столбцах
    for bar, value in zip(bars3, клиенты_отказались):
        axes[2, 0].text(bar.get_x() + bar.get_width()/2, bar.get_height() + max(клиенты_отказались) * 0.02,
                       f'{value:.0f}', ha='center', va='bottom', fontsize=10)

    # 6. Использование ресурсов
    bars4 = axes[2, 1].bar(сценарии, коэффициенты_загрузки, yerr=ci_загрузки, color=['red', 'orange', 'green'], capsize=5)
    axes[2, 1].set_ylabel('Загрузка ресурсов (%)')
    axes[2, 1].set_title('Коэффициент загрузки сотрудников')
    axes[2, 1].set_ylim(0, 100)
    axes[2, 1].axhline(y=80, color='r', linestyle='--', label='Целевая загрузка (80%)')
    axes[2, 1].legend()

    # Добавить метки значений на столбцах
    for bar, value in zip(bars4, коэффициенты_загрузки):
        axes[2, 1].text(bar.get_x() + bar.get_width()/2, bar.get_height() + 2,
                       f'{value:.0f}%', ha='center', va='bottom', fontsize=10)

    # 7. Временные ряды событий
    ax_ts = axes[3, 0]
    for i, scenario_events in enumerate(события):
        if not scenario_events: continue

        # Сортировка событий по времени
        sorted_events = sorted(scenario_events, key=lambda x: x[0])
        times, event_types = zip(*sorted_events)

        arrivals = np.cumsum([1 if e == 'прибыл' else 0 for e in event_types])
        served = np.cumsum([1 if e == 'обслужен' else 0 for e in event_types])
        dropouts = np.cumsum([1 if e == 'отказался' else 0 for e in event_types])

        ax_ts.plot(times, arrivals, linestyle='-', label=f'Прибыло ({сценарии[i]})')
        ax_ts.plot(times, served, linestyle='--', label=f'Обслужено ({сценарии[i]})')
        ax_ts.plot(times, dropouts, linestyle=':', label=f'Отказались ({сценарии[i]})')

    ax_ts.set_xlabel('Время симуляции (минуты)')
    ax_ts.set_ylabel('Количество клиентов')
    ax_ts.set_title('Динамика потока клиентов')
    ax_ts.legend()
    ax_ts.grid(True)

    # Скрыть пустой подграфик
    axes[3, 1].axis('off')

    # Настроить расположение
    plt.tight_layout(rect=[0, 0, 1, 0.96]) # Скорректировать, чтобы заголовок не накладывался
    plt.savefig('результаты_имитации_русский.png', dpi=300, bbox_inches='tight')
    plt.show()

def создать_визуализацию_бизнес_кейса():
    """Создать визуализацию для бизнес-кейса на русском языке"""

    fig, ax = plt.subplots(1, 1, figsize=(10, 6))

    # Данные по инвестициям и экономии
    категории = ['Оборудование', 'Интеграция', 'Экономия в год (консервативная)', 'Доп. эффект (оптимистичный)']
    значения = [300000, 100000, 500000, 460000]  # в рублях
    цвета = ['red', 'orange', 'green', 'lightgreen']

    bars = ax.bar(категории, значения, color=цвета)
    ax.set_ylabel('Сумма (рубли)')
    ax.set_title('Инвестиции и ROI оптимизации ПВЗ')

    # Добавить метки значений
    for bar, value in zip(bars, значения):
        ax.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 10000,
               f'{value:,}'.replace(',', ' '), ha='center', va='bottom')

    # Добавить аннотации о сроках окупаемости
    total_investment = 300000 + 100000
    conservative_savings = 500000
    payback_months = (total_investment / conservative_savings) * 12

    formula_text = f"Расчет (консервативный):\n" \
                   f"({total_investment:,} руб. / {conservative_savings:,} руб./год) * 12 мес. = {payback_months:.1f} мес.".replace(',', ' ')

    ax.annotate(formula_text,
                xy=(1, 350000), xytext=(0, 450000),
                arrowprops=dict(facecolor='black', shrink=0.05),
                horizontalalignment='center', verticalalignment='top',
                bbox=dict(boxstyle="round,pad=0.5", fc="yellow", ec="black", lw=1))

    ax.annotate('Окупаемость: 4-6 месяцев\n(оптимистичный сценарий)',
                xy=(2.5, 230000), xytext=(3.5, 400000),
                arrowprops=dict(arrowstyle='->'), fontsize=10, ha='center')

    plt.tight_layout()
    plt.savefig('бизнес_кейс_русский.png', dpi=300, bbox_inches='tight')
    plt.show()

def основная_функция():
    """Сгенерировать все визуализации на русском языке"""
    print("Генерация расширенной визуализации...")
    создать_расширенную_визуализацию()

    print("Генерация бизнес-кейса...")
    создать_визуализацию_бизнес_кейса()

    print("Визуализации сохранены как 'результаты_имитации_русский.png' и 'бизнес_кейс_русский.png'")

if __name__ == "__main__":
    основная_функция()
