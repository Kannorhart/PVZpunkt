import random
import math

# Параметры модели
ВРЕМЯ_МОДЕЛИРОВАНИЯ = 120  # 2 часа в минутах
ИНТЕНСИВНОСТЬ_ПРИБЫТИЯ = 1.0  # 1 клиент в минуту в среднем
СРЕДНЕЕ_ВРЕМЯ_ОБСЛУЖИВАНИЯ = 2.0  # Среднее время обслуживания в минутах
СТАНДАРТНОЕ_ОТКЛОНЕНИЕ = 0.5   # Стандартное отклонение времени обслуживания
ВЕРОЯТНОСТЬ_ЗАДЕРЖКИ = 0.1  # Вероятность задержки/проблемы
МИНИМАЛЬНОЕ_ВРЕМЯ_ЗАДЕРЖКИ = 1.0     # Минимальное время задержки
МАКСИМАЛЬНОЕ_ВРЕМЯ_ЗАДЕРЖКИ = 5.0     # Максимальное время задержки
КОЛИЧЕСТВО_СОТРУДНИКОВ = 3        # Количество сотрудников
ДОЛЯ_САМООБСЛУЖИВАНИЯ = 0.5 # Доля клиентов, использующих самообслуживание
КОЛИЧЕСТВО_ТЕРМИНАЛОВ = 2     # Количество терминалов самообслуживания
ВЕРОЯТНОСТЬ_ОТКАЗА = 0.05 # Вероятность ухода клиента из-за длинной очереди

class Событие:
    def __init__(self, время, тип_события, клиент=None):
        self.время = время
        self.тип = тип_события  # 'прибытие', 'уход', 'отказ'
        self.клиент = клиент

class Клиент:
    def __init__(self, id, время_прибытия):
        self.id = id
        self.время_прибытия = время_прибытия
        self.время_начала_обслуживания = None
        self.время_ухода = None
        self.время_обслуживания = max(0.1, random.normalvariate(СРЕДНЕЕ_ВРЕМЯ_ОБСЛУЖИВАНИЯ, СТАНДАРТНОЕ_ОТКЛОНЕНИЕ))
        self.самообслуживание = random.random() < ДОЛЯ_САМООБСЛУЖИВАНИЯ
        self.отказался = False  # Ушел ли клиент из-за длинной очереди

class Зона:
    """Представляет зону для реализации пчелиного алгоритма"""
    def __init__(self, id_зоны):
        self.id_зоны = id_зоны
        self.загрузка = 0  # Текущая загрузка
        self.эффективность = 1.0  # Коэффициент эффективности

class ПунктВыдачи:
    def __init__(self, количество_сотрудников, количество_терминалов, использовать_пчелиный_алгоритм=False):
        self.количество_сотрудников = количество_сотрудников
        self.количество_терминалов = количество_терминалов
        self.использовать_пчелиный_алгоритм = использовать_пчелиный_алгоритм
        
        # Отслеживание ресурсов
        self.доступные_сотрудники = количество_сотрудников
        self.доступные_терминалы = количество_терминалов
        
        # Очереди
        self.очередь_сотрудников = []  # Очередь для обслуживания сотрудниками
        self.очередь_терминалов = []  # Очередь для самообслуживания
        
        # Клиенты и события
        self.все_клиенты = []
        self.времена_ожидания = []
        self.события = []
        self.время = 0
        self.общее_количество_клиентов = 0
        
        # Реализация пчелиного алгоритма
        if использовать_пчелиный_алгоритм:
            self.зоны = [Зона(i) for i in range(3)]  # 3 зоны
        else:
            self.зоны = None
            
        # Метрики производительности
        self.клиенты_отказались = 0
        self.общая_длина_очередей = 0
        self.количество_наблюдений_очереди = 0
        
    def экспоненциальное_случайное(self, интенсивность):
        """Генерация экспоненциально распределенной случайной величины"""
        return -math.log(1.0 - random.random()) / интенсивность
    
    def запланировать_прибытие(self, время):
        """Запланировать прибытие клиента"""
        клиент = Клиент(self.общее_количество_клиентов, время)
        self.общее_количество_клиентов += 1
        self.все_клиенты.append(клиент)
        self.события.append(Событие(время, 'прибытие', клиент))
        
    def запланировать_уход(self, время, клиент):
        """Запланировать уход клиента"""
        клиент.время_ухода = время
        self.события.append(Событие(время, 'уход', клиент))
        
    def запланировать_отказ(self, время, клиент):
        """Запланировать отказ клиента (уход из-за длинной очереди)"""
        клиент.отказался = True
        self.клиенты_отказались += 1
        self.события.append(Событие(время, 'отказ', клиент))
        
    def запустить_моделирование(self, время_моделирования):
        """Запустить моделирование на заданное время"""
        # Запланировать первое прибытие
        следующее_прибытие = self.экспоненциальное_случайное(ИНТЕНСИВНОСТЬ_ПРИБЫТИЯ)
        self.запланировать_прибытие(следующее_прибытие)
        
        # Обрабатывать события до окончания времени моделирования
        while self.события and self.время < время_моделирования:
            # Сортировать события по времени
            self.события.sort(key=lambda x: x.время)
            
            # Получить следующее событие
            событие = self.события.pop(0)
            self.время = событие.время
            
            if событие.тип == 'прибытие':
                self.обработать_прибытие(событие.клиент)
                
                # Запланировать следующее прибытие, если в пределах времени моделирования
                следующее_прибытие = self.время + self.экспоненциальное_случайное(ИНТЕНСИВНОСТЬ_ПРИБЫТИЯ)
                if следующее_прибытие < время_моделирования:
                    self.запланировать_прибытие(следующее_прибытие)
                    
            elif событие.тип == 'уход':
                self.обработать_уход(событие.клиент)
                
            elif событие.тип == 'отказ':
                # Клиент ушел из-за длинной очереди - ничего не делать
                pass
        
        # Рассчитать времена ожидания для всех клиентов, которые начали обслуживание
        for клиент in self.все_клиенты:
            if клиент.время_начала_обслуживания is not None and not клиент.отказался:
                время_ожидания = клиент.время_начала_обслуживания - клиент.время_прибытия
                self.времена_ожидания.append(время_ожидания)
    
    def выбрать_зону_пчелиным_алгоритмом(self):
        """Выбрать лучшую зону с использованием пчелиного алгоритма"""
        if not self.зоны:
            return None
            
        # Найти зону с минимальной загрузкой (упрощенный пчелиный алгоритм)
        лучшая_зона = min(self.зоны, key=lambda z: z.загрузка)
        return лучшая_зона
    
    def клиент_откажется_ли(self, самообслуживание):
        """Определить, уйдет ли клиент из-за длинной очереди"""
        # Проверить длину очереди
        длина_очереди = len(self.очередь_терминалов) if самообслуживание else len(self.очередь_сотрудников)
        
        # Высшая вероятность отказа с длинными очередями
        # Базовая вероятность + фактор длины очереди
        вероятность_отказа = ВЕРОЯТНОСТЬ_ОТКАЗА + (длина_очереди * 0.02)
        return random.random() < min(вероятность_отказа, 0.5)  # Ограничить 50%
    
    def обработать_прибытие(self, клиент):
        """Обработать прибытие клиента"""
        # Проверить, уйдет ли клиент из-за длинной очереди
        if self.клиент_откажется_ли(клиент.самообслуживание):
            self.запланировать_отказ(self.время, клиент)
            return
            
        # Оптимизация пчелиным алгоритмом - выбрать лучшую зону
        if self.использовать_пчелиный_алгоритм and not клиент.самообслуживание:
            лучшая_зона = self.выбрать_зону_пчелиным_алгоритмом()
            if лучшая_зона:
                # Применить коэффициент эффективности зоны к времени обслуживания
                клиент.время_обслуживания = клиент.время_обслуживания * лучшая_зона.эффективность
                лучшая_зона.загрузка += 1  # Увеличить загрузку выбранной зоны
        
        if клиент.самообслуживание and self.доступные_терминалы > 0:
            # Обслужить немедленно на терминале самообслуживания
            self.доступные_терминалы -= 1
            клиент.время_начала_обслуживания = self.время
            
            # Запланировать уход
            время_обслуживания = клиент.время_обслуживания
            if random.random() < ВЕРОЯТНОСТЬ_ЗАДЕРЖКИ:
                время_обслуживания += random.uniform(МИНИМАЛЬНОЕ_ВРЕМЯ_ЗАДЕРЖКИ, МАКСИМАЛЬНОЕ_ВРЕМЯ_ЗАДЕРЖКИ)
            время_ухода = self.время + время_обслуживания
            self.запланировать_уход(время_ухода, клиент)
        elif not клиент.самообслуживание and self.доступные_сотрудники > 0:
            # Обслужить немедленно сотрудником
            self.доступные_сотрудники -= 1
            клиент.время_начала_обслуживания = self.время
            
            # Запланировать уход
            время_обслуживания = клиент.время_обслуживания
            if random.random() < ВЕРОЯТНОСТЬ_ЗАДЕРЖКИ:
                время_обслуживания += random.uniform(МИНИМАЛЬНОЕ_ВРЕМЯ_ЗАДЕРЖКИ, МАКСИМАЛЬНОЕ_ВРЕМЯ_ЗАДЕРЖКИ)
            время_ухода = self.время + время_обслуживания
            self.запланировать_уход(время_ухода, клиент)
        else:
            # Добавить в соответствующую очередь
            if клиент.самообслуживание:
                self.очередь_терминалов.append(клиент)
            else:
                self.очередь_сотрудников.append(клиент)
    
    def обработать_уход(self, клиент):
        """Обработать уход клиента"""
        # Освободить ресурс
        if клиент.самообслуживание:
            self.доступные_терминалы += 1
            # Уменьшить загрузку зоны, если используется пчелиный алгоритм
            if self.использовать_пчелиный_алгоритм and self.зоны:
                for зона in self.зоны:
                    if зона.загрузка > 0:
                        зона.загрузка -= 1
                        break
            
            # Проверить, есть ли кто-то в очереди терминалов
            if self.очередь_терминалов:
                следующий_клиент = self.очередь_терминалов.pop(0)
                следующий_клиент.время_начала_обслуживания = self.время
                
                # Оптимизация пчелиным алгоритмом для следующего клиента
                if self.использовать_пчелиный_алгоритм:
                    лучшая_зона = self.выбрать_зону_пчелиным_алгоритмом()
                    if лучшая_зона:
                        следующий_клиент.время_обслуживания = следующий_клиент.время_обслуживания * лучшая_зона.эффективность
                        лучшая_зона.загрузка += 1
                
                # Запланировать уход
                время_обслуживания = следующий_клиент.время_обслуживания
                if random.random() < ВЕРОЯТНОСТЬ_ЗАДЕРЖКИ:
                    время_обслуживания += random.uniform(МИНИМАЛЬНОЕ_ВРЕМЯ_ЗАДЕРЖКИ, МАКСИМАЛЬНОЕ_ВРЕМЯ_ЗАДЕРЖКИ)
                время_ухода = self.время + время_обслуживания
                self.запланировать_уход(время_ухода, следующий_клиент)
        else:
            self.доступные_сотрудники += 1
            # Уменьшить загрузку зоны, если используется пчелиный алгоритм
            if self.использовать_пчелиный_алгоритм and self.зоны:
                for зона in self.зоны:
                    if зона.загрузка > 0:
                        зона.загрузка -= 1
                        break
            
            # Проверить, есть ли кто-то в очереди сотрудников
            if self.очередь_сотрудников:
                следующий_клиент = self.очередь_сотрудников.pop(0)
                следующий_клиент.время_начала_обслуживания = self.время
                
                # Оптимизация пчелиным алгоритмом для следующего клиента
                if self.использовать_пчелиный_алгоритм:
                    лучшая_зона = self.выбрать_зону_пчелиным_алгоритмом()
                    if лучшая_зона:
                        следующий_клиент.время_обслуживания = следующий_клиент.время_обслуживания * лучшая_зона.эффективность
                        лучшая_зона.загрузка += 1
                
                # Запланировать уход
                время_обслуживания = следующий_клиент.время_обслуживания
                if random.random() < ВЕРОЯТНОСТЬ_ЗАДЕРЖКИ:
                    время_обслуживания += random.uniform(МИНИМАЛЬНОЕ_ВРЕМЯ_ЗАДЕРЖКИ, МАКСИМАЛЬНОЕ_ВРЕМЯ_ЗАДЕРЖКИ)
                время_ухода = self.время + время_обслуживания
                self.запланировать_уход(время_ухода, следующий_клиент)

def запустить_сценарий(количество_сотрудников, количество_терминалов, использовать_пчелиный_алгоритм=False, время_моделирования=ВРЕМЯ_МОДЕЛИРОВАНИЯ):
    """Запустить сценарий моделирования"""
    # Установить начальное значение для воспроизводимости
    random.seed(42)
    
    пункт_выдачи = ПунктВыдачи(количество_сотрудников, количество_терминалов, использовать_пчелиный_алгоритм)
    пункт_выдачи.запустить_моделирование(время_моделирования)
    return пункт_выдачи

def проанализировать_результаты(сценарии):
    """Проанализировать результаты различных сценариев"""
    результаты = []
    
    for название, пункт_выдачи in сценарии:
        if len(пункт_выдачи.времена_ожидания) > 0:
            среднее_время_ожидания = sum(пункт_выдачи.времена_ожидания) / len(пункт_выдачи.времена_ожидания)
            максимальное_время_ожидания = max(пункт_выдачи.времена_ожидания)
        else:
            среднее_время_ожидания = 0
            максимальное_время_ожидания = 0
        
        # Рассчитать загрузку
        общая_емкость = пункт_выдачи.количество_сотрудников + пункт_выдачи.количество_терминалов
        средняя_загрузка = 0
        if общая_емкость > 0:
            # Упрощенный расчет загрузки
            обслуженные_клиенты = len([к for к in пункт_выдачи.все_клиенты if к.время_ухода is not None])
            средняя_загрузка = min(100, (обслуженные_клиенты / (время_моделирования/2)) * 10)  # Грубое приближение
        
        результат = {
            'сценарий': название,
            'среднее_время_ожидания': среднее_время_ожидания,
            'максимальное_время_ожидания': максимальное_время_ожидания,
            'всего_клиентов': len(пункт_выдачи.все_клиенты),
            'клиентов_обслужено': len([к for к in пункт_выдачи.все_клиенты if к.время_ухода is not None]),
            'клиентов_отказалось': пункт_выдачи.клиенты_отказались,
            'коэффициент_загрузки': средняя_загрузка
        }
        результаты.append(результат)
    
    return результаты

def основная_функция():
    """Основная функция для запуска моделирования и сравнения сценариев"""
    print("Запуск улучшенной имитационной модели оптимизации ПВЗ")
    print("=" * 60)
    
    global время_моделирования
    время_моделирования = ВРЕМЯ_МОДЕЛИРОВАНИЯ
    
    # Сценарий 1: Базовый - Традиционный ПВЗ
    print("Запуск базового сценария...")
    базовый_пвз = запустить_сценарий(3, 0, False)
    
    # Сценарий 2: С терминалами самообслуживания
    print("Запуск сценария с самообслуживанием...")
    самообслуживание_пвз = запустить_сценарий(3, 2, False)
    
    # Сценарий 3: С оптимизацией по пчелиному алгоритму
    print("Запуск сценария с оптимизацией по пчелиному алгоритму...")
    пчелиный_алгоритм_пвз = запустить_сценарий(3, 2, True)
    
    # Собрать сценарии
    сценарии = [
        ("Базовый", базовый_пвз),
        ("С самообслуживанием", самообслуживание_пвз),
        ("С пчелиным алгоритмом", пчелиный_алгоритм_пвз)
    ]
    
    # Проанализировать результаты
    результаты = проанализировать_результаты(сценарии)
    
    print("\nРезультаты имитации:")
    print("-" * 50)
    for результат in результаты:
        print(f"Сценарий: {результат['сценарий']}")
        print(f"  Среднее время ожидания: {результат['среднее_время_ожидания']:.2f} минут")
        print(f"  Максимальное время ожидания: {результат['максимальное_время_ожидания']:.2f} минут")
        print(f"  Всего клиентов прибыло: {результат['всего_клиентов']}")
        print(f"  Клиентов обслужено: {результат['клиентов_обслужено']}")
        print(f"  Клиентов ушло из-за очереди: {результат['клиентов_отказалось']}")
        print(f"  Загрузка ресурсов: {результат['коэффициент_загрузки']:.1f}%")
        print()
    
    # Бизнес-оценка
    print("Бизнес-оценка:")
    print("-" * 20)
    
    базовое_среднее_ожидание = результаты[0]['среднее_время_ожидания']
    оптимизированное_среднее_ожидание = результаты[2]['среднее_время_ожидания']
    
    if базовое_среднее_ожидание > 0:
        улучшение = ((базовое_среднее_ожидание - оптимизированное_среднее_ожидание) / базовое_среднее_ожидание) * 100
        print(f"Снижение среднего времени ожидания: {улучшение:.2f}%")
        
        # Проверка эффективности: если время ожидания увеличилось, улучшение отрицательное
        if улучшение < 0:
            print("Внимание: Время ожидания увеличилось в оптимизированном сценарии")
            улучшение = abs(улучшение)  # Используем абсолютное значение для корректного сравнения
        
        # Улучшение удовлетворенности клиентов
        базовые_отказы = результаты[0]['клиентов_отказалось']
        оптимизированные_отказы = результаты[2]['клиентов_отказалось']
        if базовые_отказы > 0:
            улучшение_отказов = ((базовые_отказы - оптимизированные_отказы) / базовые_отказы) * 100
            print(f"Снижение отказов клиентов: {улучшение_отказов:.2f}%")
        
        if улучшение > 20:
            print("✓ Предложенное решение эффективно (улучшение > 20%)")
            
            # Бизнес-модель
            print("\nБизнес-модель:")
            print("-" * 15)
            стоимость_оборудования = 3 * 100000  # 3 терминала по 100,000 рублей каждый
            стоимость_интеграции = 100000    # Интеграция и обучение
            общие_инвестиции = стоимость_оборудования + стоимость_интеграции
            print(f"Стоимость оборудования: {стоимость_оборудования:,} рублей")
            print(f"Стоимость интеграции: {стоимость_интеграции:,} рублей")
            print(f"Общие инвестиции: {общие_инвестиции:,} рублей")
            
            # Расчет экономии
            экономия_на_персонале = 500000  # Экономия за счет сокращения штата на 1 человека
            увеличение_мощности = 0.30  # 30% увеличение мощности
            срок_окупаемости = общие_инвестиции / экономия_на_персонале  # В годах
            print(f"Ежегодная экономия на персонале: {экономия_на_персонале:,} рублей")
            print(f"Увеличение мощности: {увеличение_мощности*100:.0f}%")
            print(f"Срок окупаемости: {срок_окупаемости*12:.1f} месяцев")
        else:
            print("✗ Предложенное решение неэффективно (улучшение ≤ 20%)")
    else:
        print("Нет времени ожидания в базовом сценарии - невозможно рассчитать улучшение")

if __name__ == "__main__":
    основная_функция()